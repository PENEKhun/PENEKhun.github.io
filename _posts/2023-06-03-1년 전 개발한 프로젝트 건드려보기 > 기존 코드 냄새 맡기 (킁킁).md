---
layout: post

title: 1년 전 개발한 프로젝트 건드려보기 2 > 기존 코드 냄새 맡기

subtitle: Looking at a project developed a year ago - I was Human-Legacy-Maker

excerpt: "1년 전에 개발한 프로젝트를 다시 살펴보고, 그동안 얼마나 성장했는지 알아보려고 합니다."

tags:
  - Java
  - Springboot
  - Toy
  - Refactoring
  - Code Smell
published: true
---

# 기존 코드 냄새 맡기
> 원래 목차에서는 '기존 코드 리뷰와 문제점 파악하기'로 소개하였으나,  
> '기존 코드 냄새 맡기'가 더 재미있어서 이렇게 표기 하겠습니다.

바로 코드 냄새 맡아보겠습니다.  
**(수정은 다음장에서 진행 할 예정입니다)**

## 일관성이 없는 반환 타입
아래는 컨트롤러 코드 입니다.  
> 처음엔 @ResponseBody같은 것을 안쓰고 `ResponseEntity`를 왜 썼지? 싶었는데, 따로 헤더값을 지정해두더라구요. (다행...)

근데 문제는 하나만 제네릭을 String을 지정해 주고, 또 다른 하나는 원시타입을 사용하네요. (일관성이 제로...)

![일관성 없는 반환 타입 1](/assets/2023-06-03/skaqkf1.png)

![일관성 없는 반환 타입 2](/assets/2023-06-03/skaqkf2.png)

우리는 변수를 선언할때 원시 타입 (`raw type`)을 쓰면 안된다고 합니다.

```Java
List myList; // Noncompliant
Set mySet; // Noncompliant
```
이런 식으로 사용하면 컴파일러가 타입 안정성을 검사할 수 없을 수도 있습니다. 뭐 요즘 IDE가 너무 좋아져서 별문제가 되지 않을 수도 있습니다. 실제로 인텔리제이에선 원시 타입을 써도 잘 작동하니깐요.

개선을 하려면, 다음 처럼 제네릭 타입을 지정해야 합니다.

```Java
List<String> myList;
Set<? extends Number> mySet;
```


## JPA의 장점을 활용하지 못하고 있는 Repository
![JPA의 장점을 활용하지 못하고 있는 Repository 1](/assets/2023-06-03/jpa-worst.png)

![JPA의 장점을 활용하지 못하고 있는 Repository](/assets/2023-06-03/jpa-worst2.png)
보시면 `EntityManager`에 `TypedQuery`를 직접 날려주고 있었습니다.  
쿼리도 보면 단순합니다. JPA를 잘 모르는채로~~(아직도 잘 모르긴 합니다만..)~~ 코드를 작성 한 탓 인듯 합니다.  

## 키 190cm 모델보다 긴 메서드
```Java
  public JSONObject logToJson(List < LogEntity > logData) {

    JSONObject jObject = new JSONObject();

    String[] osDataSets = new String[] {
        "Unknown OS",
        "Windows",
        "MacOS",
        "Linux",
        "Android",
        "iOS"
    };
    String[] browserDataSets = new String[] {
        "Unknown Browser",
        "Chrome",
        "Firefox",
        "Trident",
        "Safari",
        "Edge",
        "Opera",
        "Whale",
        "Samsung Internet"
    };

    ArrayList < String > listPlatformAtLog = new ArrayList < > ();
    ArrayList < String > listBrowserAtLog = new ArrayList < > ();
    ArrayList < String > listCountryAtLog = new ArrayList < > ();
    ArrayList < String > listEnterAtLog = new ArrayList < > ();

    JSONArray jArray = new JSONArray();

    for (LogEntity log: logData) {
        JSONObject sObject = new JSONObject(); //배열 내에 들어갈 jsonsObject.put("country", log.getCountry());  
        listCountryAtLog.add(log.getCountry());

        sObject.put("platform", log.getPlatform());
        listPlatformAtLog.add(log.getPlatform());

        sObject.put("referer", log.getReferer());

        sObject.put("browser", log.getUserAgent());
        listBrowserAtLog.add(log.getUserAgent());

        sObject.put("time", log.getEnteredAt().toString().split(" ")[0]);
        listEnterAtLog.add(log.getEnteredAt().toString().split(" ")[0]);

        jArray.add(sObject);
    }
    jObject.put("log", jArray);

    JSONObject analyObj = new JSONObject();
    JSONArray jArray2 = new JSONArray(); //statistics  
    JSONArray jArray3 = new JSONArray(); //statistics for draw chart  
    JSONObject jObject2 = new JSONObject(); //browser  
    JSONObject jObject3 = new JSONObject(); //os platform  
    JSONObject jObject4 = new JSONObject(); //date  


    for (String browserString: browserDataSets) {
        int browserFrequnecy = Collections.frequency(listBrowserAtLog, browserString);
        jObject2.put(browserString, browserFrequnecy);
    }

    analyObj.put("browser", jObject2);

    for (String osString: osDataSets) {
        int browserFrequnecy = Collections.frequency(listPlatformAtLog, osString);
        jObject3.put(osString, browserFrequnecy);
    }

    analyObj.put("platform", jObject3);
    analyObj.put("totalVisitor", jArray.size());

    for (int i = 0; i < 7; i++) {
        JSONObject jObject5 = new JSONObject(); //date sub  
        String dateString = getDateBeforeDay(i);
        int dateFrequnecy = Collections.frequency(listEnterAtLog, dateString);
        jObject5.put("date", dateString);
        jObject5.put("day", getDayOfDate(dateString));
        jObject5.put("visitor", dateFrequnecy);
        jArray2.add(jObject5);
        log.warn(dateString);
        //jObject4.put("dayVisitor", jObject5);  
    }

    analyObj.put("dayVisitor", jArray2);
    jObject.put("statistics", analyObj);

    return jObject;
}
```

```Java
public String go(LogDto.dataCollection data) throws IOException, GeoIp2Exception {


    BigInteger idx = shortUrlToIdx(data.getHangul());

    String country = "";

    URL r = this.getClass().getResource("");

    String path = r.getPath();
    String filePath = "classpath:GeoLite2-Country_20220308/GeoLite2-Country.mmdb";
    Resource resource = resourceLoader.getResource(filePath);
    if (!resource.exists()) {
        resource = new ClassPathResource("");
        log.error("Invalid filePath : {}", filePath);
        throw new CustomException(ErrorCode.IP_DB_NOT_FOUND);
    }

    try {
        InputStream geo2Ipdatabase = new BufferedInputStream(resource.getInputStream());
        DatabaseReader reader = new DatabaseReader.Builder(geo2Ipdatabase).build();
        InetAddress ipAddress = InetAddress.getByName(data.getIp());
        CountryResponse response = reader.country(ipAddress);
        country = String.valueOf(response.getCountry().getIsoCode());
    } catch (AddressNotFoundException | UnknownHostException e) {
        country = "Unknown Country";
    }

    data.setUserAgent(data.getUserAgent().toLowerCase(Locale.ROOT));
    if (data.getUserAgent().isEmpty()) data.setUserAgent("Unknown UserAgent");

    String osName = "Unknown OS";
    if (data.getUserAgent().contains("win")) osName = "Windows";
    if (data.getUserAgent().contains("mac")) osName = "MacOS";
    if (data.getUserAgent().contains("linux")) osName = "Linux";
    if (data.getUserAgent().contains("android")) osName = "Android";
    if (data.getUserAgent().contains("like mac")) osName = "iOS";

    String browser = "Unknown Browser";
    if (data.getUserAgent().contains("chrome")) browser = "Chrome";
    if (data.getUserAgent().contains("firefox")) browser = "Firefox";
    if (data.getUserAgent().contains("trident")) browser = "IE";
    if (data.getUserAgent().contains("safari")) browser = "Safari";
    if (data.getUserAgent().contains("edge")) browser = "Edge";
    if (data.getUserAgent().contains("opera")) browser = "Opera";
    if (data.getUserAgent().contains("whale")) browser = "Whale";
    if (data.getUserAgent().contains("samsung")) browser = "Samsung Internet";


    OriginUrlDto originUrl = shortRepository.getUrl(idx);


    log.info("########## user approached at {} #########", data.getHangul());
    log.info(" connected header information");
    log.info(" ip Addr : {}", data.getIp());
    log.info(" country : {}", country);
    log.info(" userAgent : {}", data.getUserAgent());
    log.info(" browser : {}", browser);
    log.info(" platform : {}", osName);
    log.info(" referer : {}", data.getReferer());
    log.info(" origin Url : {}", originUrl.getUrl());
    log.info("################################################");

    LogEntity logEntity = LogEntity.builder().country(country)
        .pageId(originUrl.getIdx())
        .referer(data.getReferer())
        .platform(osName)
        .userAgent(browser)
        .build();

    logRepository.save(logEntity);


    return originUrl.getUrl();
}
```
둘 다 컨트롤러에서 호출되는 서비스 메서드입니다.  
  
이 정도면 코드로 소설을 쓴 듯합니다.  
나쁜 코드 냄새를 코로 맡은 게 아닌 눈으로 맡아 버렸습니다.....  
이것도 당장 수정해야겠네요...  

## 내가 작성했지만 이해하기 어려운 코드
```Java
public BigInteger shortUrlToIdx(String link) {
    try {
        link = link.substring(0, 5);

        log.info("shortUrlToIdx input : {}", link);
        String[] dataArray = link.split("");
        int[] fiveHangul = new int[3 * 5]; // 18 20 27  
        int i = 0;
        BigInteger result = new BigInteger("0");

        for (String s: dataArray) {
            int chosung = (s.charAt(0) - 0xAC00) / 588;
            int jungsung = ((s.charAt(0) - 0xAC00) % 588) / 28;
            int jongsung = (s.charAt(0) - 0xAC00) % 28; //없을 수도 있음  
            fiveHangul[i * 3] = chosung;
            fiveHangul[i * 3 + 1] = jungsung;
            fiveHangul[i * 3 + 2] = jongsung;
            i++;
        }

        result = result.add(BigInteger.valueOf(fiveHangul[0]));

        BigInteger[] arr = new BigInteger[3 * 5];
        arr[0] = BigInteger.ONE;

        for (int k = 1; k < 15; k++) {
            arr[k] = arr[k - 1].multiply(BigInteger.valueOf(getMax(k - 1)));
            result = result.add(arr[k].multiply(BigInteger.valueOf(fiveHangul[k])));
        }

        log.info("shortUrlToIdx output : {}", result);
        return result;
    } catch (StringIndexOutOfBoundsException e) {
        e.printStackTrace();
        throw new CustomException(ErrorCode.INVALID_INPUT);
    }
}
```


## 빈약하고 이상한 테스트코드
![구린내가 나는 테스트코드](/assets/2023-06-03/strange-test-code.png)
하나의 애플리케이션에서 이 테스트 코드가 끝이네요.  
더군다나 하나의 테스트에서 여러 개의 `Assertions`을 사용하고 있어 좋아 보이는 코드는 아닌듯합니다.
~~(사실 테스트코드는 아직도 어렵...)~~


# 정리
지금의 저도 많이 부족하다고 생각하지만,  
특히 과거의 저는 인간-레거시-생성기였던 것 같습니다.  
빨리 수정 하러 가 봐야겠습니다.


_그럼, 3편에서 봅시다._ ✋~

