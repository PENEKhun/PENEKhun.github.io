---
layout: post
title: 원티드 프리온보딩 백엔드 API 인증 인가 구현
tags:
  - Toy
  - Springboot
  - Wanted2023
  - SpringSecurity
categories:
  - 스프링부트
published: false
---
<a href="/posts/심심해서-구현해보는-원티드-2023-프리온보딩-백엔드-인턴십-선발과제-2/" target="_blank">이전포스트</a>에서 요구사항을 분석하고 데이터베이스를 설계 했으니, 이제 본격적으로 기능 구현에 앞서서 `Spring Security`를 통한 인증인가 구현을 해보겠습니다.

일단, [Spring Security](https://docs.spring.io/spring-security/reference/servlet/authentication/index.html#servlet-authentication-mechanisms)가 제공하는 인증 매커니즘(`Authentication Mechanisms`)은 다음과 같습니다.

- Authentication Mechanisms  
	- [Username and Password](https://docs.spring.io/spring-security/reference/servlet/authentication/passwords/index.html#servlet-authentication-unpwd) - how to authenticate with a username/password  
	- [OAuth 2.0 Login](https://docs.spring.io/spring-security/reference/servlet/oauth2/login/index.html#oauth2login) - OAuth 2.0 Log In with OpenID Connect and non-standard OAuth 2.0 Login (i.e. GitHub)  
	- [SAML 2.0 Login](https://docs.spring.io/spring-security/reference/servlet/saml2/index.html#servlet-saml2) - SAML 2.0 Log In  
	- [Central Authentication Server (CAS)](https://docs.spring.io/spring-security/reference/servlet/authentication/cas.html#servlet-cas) - Central Authentication Server (CAS) Support  
	- [Remember Me](https://docs.spring.io/spring-security/reference/servlet/authentication/rememberme.html#servlet-rememberme) - how to remember a user past session expiration  
	- [JAAS Authentication](https://docs.spring.io/spring-security/reference/servlet/authentication/jaas.html#servlet-jaas) - authenticate with JAAS  
	- [Pre-Authentication Scenarios](https://docs.spring.io/spring-security/reference/servlet/authentication/preauth.html#servlet-preauth) - authenticate with an external mechanism such as [SiteMinder](https://www.siteminder.com/) or Java EE security but still use Spring Security for authorization and protection against common exploits.  
	- [X509 Authentication](https://docs.spring.io/spring-security/reference/servlet/authentication/x509.html#servlet-x509) - X509 Authentication  

해당 프로젝트에선,  
**로그인(ID, PW)** 을 통해 JWT Access Token를 반환시키고, 매 요청 Header에 해당 토큰 값을 포함시킬 예정이기 때문에, `Username and Password` 인증 매커니즘을 사용할 예정입니다.

일단 `UsernamePasswordAuthenticationFilter`를 한번 살펴 봅시다.

```java
public class UsernamePasswordAuthenticationFilter extends AbstractAuthenticationProcessingFilter {
.....
}
```
{: file='UsernamePasswordAuthenticationFilter.class'}

`UsernamePasswordAuthenticationFilter`는 `AbstractAuthenticationProcessingFilter`의 상속 받고 있습니다.


```java
/**
Abstract processor of browser-based HTTP-based authentication requests.

### Authentication Process

The filter requires that you set the authenticationManager property. An AuthenticationManager is required to process the authentication request tokens created by implementing classes.

This filter will intercept a request and attempt to perform authentication from that request if the request matches the [`setRequiresAuthenticationRequestMatcher(RequestMatcher)`](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/AbstractAuthenticationProcessingFilter.html#setRequiresAuthenticationRequestMatcher(org.springframework.security.web.util.matcher.RequestMatcher)).

Authentication is performed by the [`attemptAuthentication`](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/AbstractAuthenticationProcessingFilter.html#attemptAuthentication(jakarta.servlet.http.HttpServletRequest,jakarta.servlet.http.HttpServletResponse)) method, which must be implemented by subclasses.

#### Authentication Success

If authentication is successful, the resulting [`Authentication`](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/core/Authentication.html "interface in org.springframework.security.core") object will be placed into the `SecurityContext` for the current thread, which is guaranteed to have already been created by an earlier filter.

The configured [`AuthenticationSuccessHandler`](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/AbstractAuthenticationProcessingFilter.html#setAuthenticationSuccessHandler(org.springframework.security.web.authentication.AuthenticationSuccessHandler)) will then be called to take the redirect to the appropriate destination after a successful login. The default behaviour is implemented in a [`SavedRequestAwareAuthenticationSuccessHandler`](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/SavedRequestAwareAuthenticationSuccessHandler.html "class in org.springframework.security.web.authentication") which will make use of any DefaultSavedRequest set by the ExceptionTranslationFilter and redirect the user to the URL contained therein. Otherwise it will redirect to the webapp root "/". You can customize this behaviour by injecting a differently configured instance of this class, or by using a different implementation.

See the [`successfulAuthentication(HttpServletRequest, HttpServletResponse, FilterChain, Authentication)`](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/AbstractAuthenticationProcessingFilter.html#successfulAuthentication(jakarta.servlet.http.HttpServletRequest,jakarta.servlet.http.HttpServletResponse,jakarta.servlet.FilterChain,org.springframework.security.core.Authentication)) method for more information.

#### Authentication Failure

If authentication fails, it will delegate to the configured [`AuthenticationFailureHandler`](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/AuthenticationFailureHandler.html "interface in org.springframework.security.web.authentication") to allow the failure information to be conveyed to the client. The default implementation is [`SimpleUrlAuthenticationFailureHandler`](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/SimpleUrlAuthenticationFailureHandler.html "class in org.springframework.security.web.authentication") , which sends a 401 error code to the client. It may also be configured with a failure URL as an alternative. Again you can inject whatever behaviour you require here.

#### Event Publication

If authentication is successful, an [`InteractiveAuthenticationSuccessEvent`](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/authentication/event/InteractiveAuthenticationSuccessEvent.html "class in org.springframework.security.authentication.event") will be published via the application context. No events will be published if authentication was unsuccessful, because this would generally be recorded via an `AuthenticationManager`-specific application event.

#### Session Authentication

The class has an optional [`SessionAuthenticationStrategy`](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/session/SessionAuthenticationStrategy.html "interface in org.springframework.security.web.authentication.session") which will be invoked immediately after a successful call to `attemptAuthentication()`. Different implementations [`can be injected`](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/AbstractAuthenticationProcessingFilter.html#setSessionAuthenticationStrategy(org.springframework.security.web.authentication.session.SessionAuthenticationStrategy)) to enable things like session-fixation attack prevention or to control the number of simultaneous sessions a principal may have.
*/
public abstract class AbstractAuthenticationProcessingFilter extends GenericFilterBean  
   implements ApplicationEventPublisherAware, MessageSourceAware {
....

}
```
{: file='AbstractAuthenticationProcessingFilter.class'}

- `AbstractAuthenticationProcessingFilter`의 JavaDoc 문서를 요약해보면 다음과 같습니다.  
	- AbstractAuthenticationProcessingFilter는 브라우저 기반 HTTP 기반 인증 요청의 추상 Processor 이다.  
	- 인증 프로세스는 다음과 같다.  
		> 인증은 [`attemptAuthentication`](https://docs.spring.io/spring-security/site/docs/current/api/org/springframework/security/web/authentication/AbstractAuthenticationProcessingFilter.html#attemptAuthentication(jakarta.servlet.http.HttpServletRequest,jakarta.servlet.http.HttpServletResponse)) 메서드에 의해 수행되며, 이 메서드는 서브클래스에 의해 구현되어야 합니다.  

		- **Authentication Success**  
			로그인에 성공하면 구성된 AuthenticationSuccessHandler가 호출되어 적절한 대상으로 리디렉션 되는데... 다른 구현을 사용하여 이 동작을 사용자 정의할 수 있다.  
		- **Authentication Failure**  
			인증에 실패하면 구성된 AuthenticationFailureHandler에 위임하여 실패 정보를 클라이언트에 전달함 *(기본 구현은 401 오류 코드 전송)* . 다시 말하지만 여기에 필요한 모든 동작을 삽입할 수 있다.  
		- *(후략....)*  

해당 JavaDoc에 따라서, 아이디 패스워드 기반 JWT 토큰 인증을 구현 하려면 다음과 같은 절차를 생각 할 수 있습니다.
- `UsernamePasswordAuthenticationFilter`의 상속을 받는 커스텀한 필터를 만든다
	- `attemptAuthentication`를 구현한다.
		- HTTP Request에서 아이디 패스워드 정보를 가져온다.
		- 가져온 정보를 통해 로그인을 진행한다.
	- `successfulAuthentication`를 Override한다.
		- 생성된 JWT AccessToken을 헤더에 포함하여 Response하도록 한다.

따라서 바로 코드를 작성해보도록 하겠습니다.

- JwtTokenProvider  
`JwtTokenProvider` 클래스를 만들어서, 토큰을 생성하는 코드를 작성했습니다.
```java
@Slf4j  
@Component  
public class JwtTokenProvider implements InitializingBean {  
  
  private static final String TOKEN = "token";  
  private static final String USERNAME = "username";  
  private final String secret;  
  private final long tokenValidityInMilliseconds;  
  private Key key;  
  
  public JwtTokenProvider(  
      @Value("${jwt.secret}") String secret,  
      CustomUserDetailsService userDetailsService) {  
    this.secret = secret;  
    this.tokenValidityInMilliseconds = tokenValidityInSeconds * 1000;  
  }  
  
  @Override  
  public void afterPropertiesSet() {  
    // 빈 생성시 키 값 전달  
    byte[] keyBytes = Decoders.BASE64.decode(secret);  
    this.key = Keys.hmacShaKeyFor(keyBytes);  
  }  
  
  public Map<String, String> createToken(String username) {  
  
    long now = (new Date()).getTime();  
    Date validity = new Date(now + this.tokenValidityInMilliseconds);  
  
    Map<String, String> map = new HashMap<>();  
    map.put(TOKEN, Jwts.builder()  
        .claim(USERNAME, username)  
        .signWith(key, SignatureAlgorithm.HS512)  
        .setExpiration(validity)  
        .compact());  
    map.put("tokenExpired", String.valueOf(validity));  
  
    return map;  
  }    
}
```

