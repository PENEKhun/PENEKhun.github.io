---
layout: post
title: "ìê¸°ì°¸ì¡°ê´€ê³„ì—ì„œ JSONì„ ì§ë ¬í™”í• ë•Œ ìˆœí™˜ì°¸ì¡°ë¥¼ í•´ê²°í•˜ëŠ” ë²•"
subtitle: "Resolving Circular References When Serializing JSON in Self-Referential Relationships."
excerpt: "ë³¸ í¬ìŠ¤íŠ¸ì—ì„œëŠ” ìê¸°ì°¸ì¡°ê´€ê³„ ì—”í‹°í‹°ì—ì„œ ë°ì´í„°ë¥¼ ì¡°íšŒí•˜ê³ , JSONìœ¼ë¡œ ì§ë ¬í™”í• ë•Œ ë¬´í•œ ìˆœí™˜ ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ë°©ë²•ì„, ëŒ“ê¸€-ëŒ€ëŒ“ê¸€ ë„ë©”ì¸ì„ ì˜ˆì‹œë¡œ ê³µìœ í•©ë‹ˆë‹¤."

tags:
  - Springboot
  - JsonSerialization
categories: [ìŠ¤í”„ë§ë¶€íŠ¸]

image:
  path: /assets/2023-07-11/thumb.png
  alt: 2022 ì¹´íƒ€ë¥´ ì›”ë“œì»µ Hì¡°ì—ì„œ ì¼ì–´ë‚œ ìˆœí™˜ì°¸ì¡°!?
  
published: true
---



ë³¸ í¬ìŠ¤íŠ¸ì—ì„œëŠ” ìê¸°ì°¸ì¡°ê´€ê³„ Entityì—ì„œ ë°ì´í„°ë¥¼ ì¡°íšŒí•˜ê³ , JSONìœ¼ë¡œ ì§ë ¬í™”í• ë•Œ ë¬´í•œ ìˆœí™˜ ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ë°©ë²•ì„, ê²Œì‹œíŒ ëŒ“ê¸€-ëŒ€ëŒ“ê¸€ êµ¬í˜„ì„ ì˜ˆì‹œë¡œ ê³µìœ í•©ë‹ˆë‹¤.


### ì˜ˆì‹œ ìƒí™©
#### ë°ì´í„°ë² ì´ìŠ¤ í…Œì´ë¸”
![](/assets/2023-07-11/erd.png){: width="500"}
#### ì—”í‹°í‹° í´ë˜ìŠ¤
```java
// ....(ìƒëµ)
public class Comment extends BaseTimeEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id", nullable = false)
    private Long id;

    @Column(name = "post_type", length = 15)
    private String postType;

    @Column(name = "post_id", nullable = false)
    private Long postId;

    @OneToOne
    @JoinColumn(name = "writer_id")
    private User writer;

    @Column(name = "content", nullable = false, length = 500)
    private String content;

    @Column(name = "is_removed", nullable = false)
    private boolean isRemoved = false;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "parent_comment_id")
    private Comment parentComment;

    @OneToMany(mappedBy = "parentComment", fetch = FetchType.LAZY)
    private List<Comment> childComments;
}
```
{: file='Comment.java'}

`comment` ì—”í‹°í‹°ëŠ” í•˜ë‚˜ì˜ í…Œì´ë¸”ì—ì„œ ëŒ“ê¸€ê³¼ ëŒ€ëŒ“ê¸€ì„ í‘œí˜„í•˜ê³  ìˆê¸° ë•Œë¬¸ì—,  
`parentComment`, `childComments` í•„ë“œë¡œ ìê¸°ì°¸ì¡°ë¥¼ í•˜ê³  ìˆìŠµë‹ˆë‹¤.  

### ëŒ“ê¸€-ëŒ€ëŒ“ê¸€ ì¡°íšŒ Repository

```java
public List<Comment> getCommentsByPost(String postType, Long postId) {
	return queryFactory.selectFrom(comment)
			.leftJoin(comment.childComments).fetchJoin()
			.leftJoin(comment.writer).fetchJoin()
			.where(checkPost(postType, postId)
					.and(isParentComment()))
			.fetch();
}
```
{: file='CommentRepository.java'}

#### ì‹¤í–‰ ê²°ê³¼

RestControllerì—ì„œ Repositoryì˜ `getCommentsByPost()`ë¥¼ í˜¸ì¶œí•˜ì—¬ List<Comment\>ë¥¼ ì¶œë ¥í•œ ê²°ê³¼ì…ë‹ˆë‹¤.

```csharp
2023-07-11T19:43:29.320+09:00 ERROR 93162 --- [nio-8080-exec-1] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: org.springframework.http.converter.HttpMessageNotWritableException: Could not write JSON: Infinite recursion (StackOverflowError)] with root cause
java.lang.StackOverflowError: null
   at java.base/java.lang.ClassLoader.defineClass1(Native Method) ~[na:na]
   at java.base/java.lang.ClassLoader.defineClass(ClassLoader.java:1012 undefined) ~[na:na]
   at java.base/java.security.SecureClassLoader.defineClass(SecureClassLoader.java:150 undefined) ~[na:na]
   at java.base/jdk.internal.loader.BuiltinClassLoader.defineClass(BuiltinClassLoader.java:862 undefined) ~[na:na]
   at java.base/jdk.internal.loader.BuiltinClassLoader.findClassOnClassPathOrNull(BuiltinClassLoader.java:760 undefined) ~[na:na]
   at java.base/jdk.internal.loader.BuiltinClassLoader.loadClassOrNull(BuiltinClassLoader.java:681 undefined) ~[na:na]
   at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:639 undefined) ~[na:na]
   at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188 undefined) ~[na:na]
   at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:520 undefined) ~[na:na]
   at com.fasterxml.jackson.databind.JsonMappingException.prependPath(JsonMappingException.java:455 undefined) ~[jackson-databind-2.15.0.jar:2.15.0]
   at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeFields(BeanSerializerBase.java:790 undefined) ~[jackson-databind-2.15.0.jar:2.15.0]
   at com.fasterxml.jackson.databind.ser.BeanSerializer.serialize(BeanSerializer.java:178 undefined) ~[jackson-databind-2.15.0.jar:2.15.0]
   at com.fasterxml.jackson.databind.ser.BeanPropertyWriter.serializeAsField(BeanPropertyWriter.java:732 undefined) ~[jackson-databind-2.15.0.jar:2.15.0]
   at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeFields(BeanSerializerBase.java:772 undefined) ~[jackson-databind-2.15.0.jar:2.15.0]
   at com.fasterxml.jackson.databind.ser.BeanSerializer.serialize(BeanSerializer.java:178 undefined) ~[jackson-databind-2.15.0.jar:2.15.0]
   at com.fasterxml.jackson.databind.ser.std.CollectionSerializer.serializeContents(CollectionSerializer.java:145 undefined) ~[jackson-databind-2.15.0.jar:2.15.0]
   at com.fasterxml.jackson.databind.ser.std.CollectionSerializer.serialize(CollectionSerializer.java:107 undefined)
```
{: file='ì—ëŸ¬ ë¡œê·¸'}

JSONìœ¼ë¡œ ì§ë ¬í™”ë¥¼ í•˜ëŠ” ê³¼ì •ì—ì„œ,  
ë¬´í•œìœ¼ë¡œ ìê¸°ì°¸ì¡°ë¥¼ ì§„í–‰í•´ì„œ `ìŠ¤íƒì˜¤ë²„í”Œë¡œìš°` ì˜¤ë¥˜ê°€ ë–´ìŠµë‹ˆë‹¤.

### í•´ê²° í•˜ëŠ” ë°©ë²•
> ë‹¤ì–‘í•œ ë°©ë²•ì´ ìˆì§€ë§Œ, ë³¸ í¬ìŠ¤íŒ…ì—ì„  ë‘ê°€ì§€ë§Œ ì–¸ê¸‰í•˜ê² ìŠµë‹ˆë‹¤.
 
1. **`@JsonBackReference`ë‘ `@JsonManagedReference`ë¥¼ ì‚¬ìš©í•˜ê¸°**  
	`com.fasterxml.jackson` íŒ¨í‚¤ì§€ì—ì„œëŠ” ë‹¤ìŒê³¼ ê°™ì€ Annotationì„ ì§€ì›í•©ë‹ˆë‹¤.
	ê° Annotationë“¤ì˜ Java-docì„ í™•ì¸í•´ë³¼ê¹Œìš”?
	
	- @JsonBackReference

	```java
	/**  
	* Annotation used to indicate that associated property is part of  
	* two-way linkage between fields; and that its role is "child" (or "back") link.  
	* Value type of the property must be a bean: it can not be a Collection, Map,  
	* Array or enumeration.  
	* Linkage is handled such that the property  
	* annotated with this annotation is not serialized; and during deserialization,  
	* its value is set to instance that has the "managed" (forward) link.  
	*<p>  
	* All references have logical name to allow handling multiple linkages; typical case  
	* would be that where nodes have both parent/child and sibling linkages. If so,  
	* pairs of references should be named differently.  
	* It is an error for a class to have multiple back references with same name,  
	* even if types pointed are different.  
	*<p>  
	* Note: only methods and fields can be annotated with this annotation: constructor  
	* arguments should NOT be annotated, as they can not be either managed or back  
	* references.  
	*/
```
	{: file='doc of @JsonBackReference'}
	
	*(JsonBackReference ì´ˆê°„ë‹¨ ë²ˆì—­)*  
	-> ì–‘ë°©í–¥ ë§í¬ì—ì„œ ê·¸ ì—­í• ì´ í•˜ìœ„(child) ë§í¬ì„ì„ ë‚˜íƒ€ë‚´ëŠ”ë° ì‚¬ìš©í•˜ëŠ” ì–´ë…¸í…Œì´ì…˜ì…ë‹ˆë‹¤.  
	ì´ ì–´ë…¸í…Œì´ì…˜ìœ¼ë¡œ ì–´ë…¸í…Œì´ì…˜ëœ í”„ë¡œí¼í‹°ê°€ ì§ë ¬í™”ë˜ì§€ ì•Šë„ë¡ ì²˜ë¦¬ë˜ë©°, ì—­ì§ë ¬í™” ì¤‘ì— í•´ë‹¹ ê°’ì€ "managed" ë§í¬ê°€ ìˆëŠ” ì¸ìŠ¤í„´ìŠ¤ë¡œ ì„¤ì •ë©ë‹ˆë‹¤.
	
	- @JsonManagedReference

	```java
	/**  
	* Annotation used to indicate that annotated property is part of  
	* two-way linkage between fields; and that its role is "parent" (or "forward") link.  
	* Value type (class) of property must have a single compatible property annotated with  
	* {@link JsonBackReference}. Linkage is handled such that the property  
	* annotated with this annotation is handled normally (serialized normally, no  
	* special handling for deserialization); it is the matching back reference  
	* that requires special handling  
	*<p>  
	* All references have logical name to allow handling multiple linkages; typical case  
	* would be that where nodes have both parent/child and sibling linkages. If so,  
	* pairs of references should be named differently.  
	* It is an error for a class to have multiple managed references with same name,  
	* even if types pointed are different.  
	*<p>  
	* Note: only methods and fields can be annotated with this annotation: constructor  
	* arguments should NOT be annotated, as they can not be either managed or back  
	* references.  
	*  
	* @author tatu  
	*/
	```
	{: file='doc of @JsonManagedReference'}
	
	*(JsonManagedReference ì´ˆê°„ë‹¨ ë²ˆì—­)*  
	-> ì–‘ë°©í–¥ ë§í¬ì—ì„œ ê·¸ ì—­í• ì´ ìƒìœ„(parent) ë§í¬ì„ì„ ë‚˜íƒ€ë‚´ëŠ”ë° ì‚¬ìš©í•˜ëŠ” ì–´ë…¸í…Œì´ì…˜ì…ë‹ˆë‹¤.  ì´ ì–´ë…¸í…Œì´ì…˜ìœ¼ë¡œ ì–´ë…¸í…Œì´ì…˜ëœ í”„ë¡œí¼í‹°ê°€ ì •ìƒì ìœ¼ë¡œ ì²˜ë¦¬ë˜ë„ë¡ ì²˜ë¦¬ë©ë‹ˆë‹¤.(ì •ìƒì ìœ¼ë¡œ ì§ë ¬í™”, ì—­ì§ë ¬í™”ë¥¼ ìœ„í•œ íŠ¹ë³„í•œ ì²˜ë¦¬ ì—†ìŒ)
	
	ìµœì¢… ìš”ì•½í•˜ë©´,  
	ì§ë ¬í™”ë¥¼ ìˆ˜í–‰í•  í•„ë“œ -> `@JsonManagedReference` 
	ì§ë ¬í™”ë¥¼ ìˆ˜í–‰í•˜ì§€ ì•Šì„ í•„ë“œ -> `@JsonBackReference` ë¥¼ ì‚¬ìš© í•˜ë¼ê³  í•©ë‹ˆë‹¤.

	```java
	@JsonBackReference // ì—¬ê¸°!!
	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "parent_comment_id")
	private Comment parentComment;
	
	@JsonManagedReference // ì—¬ê¸°!!
	@OneToMany(mappedBy = "parentComment", fetch = FetchType.LAZY)
	private List<Comment> childComments;
	```
	{: file='Comment.java'}
	ë”°ë¼ì„œ `childComments` í•„ë“œì— `@JsonManagedReference`ë¥¼ ë¶™ì¸ë‹¤ë©´ í•´ë‹¹ í•„ë“œëŠ” ì§ë ¬í™”ê°€ ë˜ê³ , `parentComment` í•„ë“œì— `@JsonBackReference`ë¥¼ ë¶™ì¸ë‹¤ë©´ "Managed" ê°€ ë¶™ì–´ì§„ ì¸ìŠ¤í„´ìŠ¤ë¡œ ëŒ€ì²´ë˜ê¸° ë•Œë¬¸ì— **ìˆœí™˜ì°¸ì¡°ê°€ ë°œìƒí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤**.

1. **Entity ê°ì²´ê°€ ì•„ë‹Œ, DTO ê°ì²´ë¡œ ë³€í™˜í•˜ì—¬ ì‚¬ìš©í•˜ê¸°**  
  - ì—”í‹°í‹°ë¥¼ ì§ë ¬í™” í•˜ëŠ”ê²Œ ì•„ë‹Œ, ë³„ë„ì˜ DTOí´ë˜ìŠ¤ë¥¼ ì§ë ¬í™”í•˜ê²Œ ëœë‹¤ë©´, ìˆœí™˜ ì°¸ì¡°ë¥¼ ë§‰ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
	```java
	@Getter
	@NoArgsConstructor
	public class CommentResponse {
	    private CommentItem parentComment;
	    private List<CommentItem> childComments = new ArrayList<>();
	
	    public CommentResponse(CommentItem parentComment, List<CommentItem> childComments) {
	        this.parentComment = parentComment;
	        this.childComments = childComments;
	    }
	
	    @Getter
	    @SuperBuilder
	    public static class CommentItem extends LocalDateResponse {
	        private final Long id;
	        private final UserDto writer;
	        private final String content;
	
	        public CommentItem(LocalDateResponseBuilder<?, ?> b, Long id, UserDto writer, String content) {
	            super(b);
	            this.id = id;
	            this.writer = writer;
	            this.content = content;
	        }
	    }
	}
	```
	{: file='CommentResponse.java'}
	ë³„ë„ë¡œ ìƒì„±í•œ DTO í´ë˜ìŠ¤ ì…ë‹ˆë‹¤.  

	```java
	public List<CommentResponse> getCommentsByPost(String postType, Long postId) {
		List<Comment> result = queryFactory.selectFrom(comment)
				.leftJoin(comment.childComments).fetchJoin()
				.leftJoin(comment.writer).fetchJoin()
				.where(checkPost(postType, postId)
						.and(isParentComment()))
				.fetch();
	
		return commentToResponse(result); // !!!ë³„ë„ì˜ ë³€í™˜ ë©”ì„œë“œ!!!
	}
	
	private List<CommentResponse> commentToResponse(List<Comment> result) {
		// Entity To DTO ë³€í™˜ ë¡œì§
		return response;
	}
	```
	{: file='CommentRepository.java'}
	Repositoryì—ì„œ `commentToResponse()`ë©”ì„œë“œë¥¼ ì´ìš©í•˜ì—¬ ì¿¼ë¦¬ ê²°ê³¼ë¥¼ DTOë¡œ ë³€í™˜ í–ˆìŠµë‹ˆë‹¤.
	![](/assets/2023-07-11/result.png)
	
	ì •ìƒì ìœ¼ë¡œ ì˜ ì¶œë ¥ë˜ë„¤ìš”. ğŸ‘