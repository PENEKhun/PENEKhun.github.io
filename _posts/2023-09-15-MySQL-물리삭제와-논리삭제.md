---
layout: post
title: MySQL 물리삭제와 논리삭제
tags:
  - MySQL
categories:
  - 데이터베이스
published: false
---
한 3달전쯤에 [백기선님 라이브방송](https://www.youtube.com/channel/UCwjaZf1WggZdbczi36bWlBA)에서 다른 분이 만든 API를 코드 리뷰하던 도중 CRUD 얘기가 나왔었다. 이때 어느 한 시청자분이 다음과 같이 채팅을 남기셨다.
> 시청자 A : 실제로 현업에선 CRUD보단 CRU만 사용하죠 (웃음)  

이에 백기선님도 어느 정도 동의하셨던 것 같았다.
과연 CRUD를 안 쓰고 CRU만 쓴다는 건 무슨 뜻이며, 어떤 의미가 있을까?

# CRUD
CRUD는 **C**reate, **R**ead, **U**pdate, **D**elete의 줄임말이다([위키피디아](https://ko.wikipedia.org/wiki/CRUD)). 흔히들 REST API를 만들면서 보았을 것이다.
게시판 기능을 만든다면, 글 생성은 Create에 해당하고, 글 조회는 Read, 글 수정은 Update, 글 삭제는 Delete에 해당 할 것이다. 흔히들 하나의 API를 만들때 CRUD를 모두 구현하곤 한다.

하지만 시청자분이 말씀하신 CRU는 무엇을 의미한 것일까?
# CRU
CRU는 원래 사전에 있는 단어는 아니다. 단순히 아까 말했던 **C**reate, **R**ead, **U**pdate, **D**elete에서 *Delete*를 제외하고 부른 것이다.  
그 말인즉슨... 삭제 기능은 만들지 않는다는 것인가?라고 생각할 수 있다. 하지만 그건 아니다.  
다음 챕터에서 확인해 보자.

# 물리삭제 VS 논리삭제
## 물리삭제
물리삭제는 말 그대로 물리적으로 삭제하는 것이다. 즉 진짜 삭제한다는 의미인 것이다.

| 게시물ID | 제목                  | 내용                                         | 작성자ID | 작성자이름 | 작성일시             | 조회수 | 좋아요수 |
|----------|-----------------------|----------------------------------------------|----------|------------|---------------------|--------|----------|
| 1        | 첫 번째 게시물     | 이 게시물은 첫 번째 게시물입니다.     | 101      | 홍길동     | 2023-09-13 10:00:00 | 250    | 32       |
| 2        | 두 번째 게시물     | 두 번째 게시물의 내용입니다.           | 102      | 김철수     | 2023-09-13 10:10:00 | 130    | 15       |
| 3        | 새로운 게시물       | 이 게시물은 최근에 작성된 게시물입니다. | 103      | 이영희     | 2023-09-13 10:20:00 | 98     | 20       |
| 4        | 인기 있는 게시물 | 많은 사람들이 좋아하는 게시물입니다.   | 104      | 박철영     | 2023-09-13 10:30:00 | 750    | 120      |
| 5        | 마지막 게시물       | 이 게시물은 마지막 게시물입니다.       | 105      | 정민지     | 2023-09-13 10:40:00 | 63     | 8        |

만약에 이런 게시판 테이블 이 있다고 가정해 보자.  
첫번째 게시물을 물리삭제로 삭제한다고 하면,

| 게시물ID | 제목                  | 내용                                         | 작성자ID | 작성자이름 | 작성일시             | 조회수 | 좋아요수 |
|----------|-----------------------|----------------------------------------------|----------|------------|---------------------|--------|----------|
| 2        | 두 번째 게시물     | 두 번째 게시물의 내용입니다.           | 102      | 김철수     | 2023-09-13 10:10:00 | 130    | 15       |
| 3        | 새로운 게시물       | 이 게시물은 최근에 작성된 게시물입니다. | 103      | 이영희     | 2023-09-13 10:20:00 | 98     | 20       |
| 4        | 인기 있는 게시물 | 많은 사람들이 좋아하는 게시물입니다.   | 104      | 박철영     | 2023-09-13 10:30:00 | 750    | 120      |
| 5        | 마지막 게시물       | 이 게시물은 마지막 게시물입니다.       | 105      | 정민지     | 2023-09-13 10:40:00 | 63     | 8        |

이런식으로 정말 삭제하게 된다.
## 논리삭제
논리삭제는 말 그대로 논리적으로 삭제한다는 것이다.
논리삭제를 하기 위해선 여러가지 방법이 있겠지만, 제일 대표적인 방법으로는 별도의 삭제여부 칼럼을 두는 것이다.

| 게시물ID | 제목                  | 내용                                         | 작성자ID | 작성자이름 | 작성일시             | 조회수 | 좋아요수 | 삭제여부 |
|----------|-----------------------|----------------------------------------------|----------|------------|---------------------|--------|----------|------|
| 1        | 첫 번째 게시물     | 이 게시물은 첫 번째 게시물입니다.     | 101      | 홍길동     | 2023-09-13 10:00:00 | 250    | 32       | false |
| 2        | 두 번째 게시물     | 두 번째 게시물의 내용입니다.           | 102      | 김철수     | 2023-09-13 10:10:00 | 130    | 15       | false |
| 3        | 새로운 게시물       | 이 게시물은 최근에 작성된 게시물입니다. | 103      | 이영희     | 2023-09-13 10:20:00 | 98     | 20       | false |
| 4        | 인기 있는 게시물 | 많은 사람들이 좋아하는 게시물입니다.   | 104      | 박철영     | 2023-09-13 10:30:00 | 750    | 120      | false |
| 5        | 마지막 게시물       | 이 게시물은 마지막 게시물입니다.       | 105      | 정민지     | 2023-09-13 10:40:00 | 63     | 8        | false |

이전 예시와 달리, 별도의 '삭제여부'라는 이름의 칼럼이 생겼다.
만약 첫번째 게시물을 논리삭제로 삭제한다고 하면,

| 게시물ID | 제목                  | 내용                                         | 작성자ID | 작성자이름 | 작성일시             | 조회수 | 좋아요수 | 삭제여부 |
|----------|-----------------------|----------------------------------------------|----------|------------|---------------------|--------|----------|------|
| 1        | 첫 번째 게시물     | 이 게시물은 첫 번째 게시물입니다.     | 101      | 홍길동     | 2023-09-13 10:00:00 | 250    | 32       | true |
| 2        | 두 번째 게시물     | 두 번째 게시물의 내용입니다.           | 102      | 김철수     | 2023-09-13 10:10:00 | 130    | 15       | false |
| 3        | 새로운 게시물       | 이 게시물은 최근에 작성된 게시물입니다. | 103      | 이영희     | 2023-09-13 10:20:00 | 98     | 20       | false |
| 4        | 인기 있는 게시물 | 많은 사람들이 좋아하는 게시물입니다.   | 104      | 박철영     | 2023-09-13 10:30:00 | 750    | 120      | false |
| 5        | 마지막 게시물       | 이 게시물은 마지막 게시물입니다.       | 105      | 정민지     | 2023-09-13 10:40:00 | 63     | 8        | false 

이런식으로 첫번째 게시물 삭제여부가 true로 변경되며 삭제되게 된다.
여기서 주의해야 될점은 삭제된 게시물을 조회하지 않기 위해서, 매번 조회할때 마다 `삭제여부 = false`과 같은 where절을 추가하여야 한다.

- SQL 쿼리 기준
WHERE is_deleted = false 추가
```sql
SELECT * FROM board WHERE writer_id = 블라블라 AND is_deleted = false
```
{: file='Example.sql'}

- JPA 엔티티 기준
클래스 상위에 `@Where()` 어노테이션을 추가하면 된다.
```java
@Entity  
@Table(name = "save")  
@Where(clause = "is_removed = 0") // 이렇게 !!
public class Member extends BaseTimeEntity {
	// ....... 생략
}
```
{: file='MemberEntity.java'}

# // 이렇게 삭제하는 이유
ㅁㅁㄴㅇㅁㄴㅇㄴㅁㅇㅁㄴㅇㅁㄴㅇㄴㅁㅁㄴㅁㅁㄴㅇㅁㄴㅇㄴㅁㅇㅁㄴㅇㅁㄴㅇㄴㅁㅁㄴㅁㅁㄴㅇㅁㄴㅇㄴㅁㅇㅁㄴㅇㅁㄴㅇㄴㅁㅁㄴㅁㅁㄴㅇㅁㄴㅇㄴㅁㅇㅁㄴㅇㅁㄴㅇㄴㅁㅁㄴㅁㅁㄴㅇㅁㄴㅇㄴㅁㅇㅁㄴㅇㅁㄴㅇㄴㅁㅁㄴㅁㅁㄴㅇㅁㄴㅇㄴㅁㅇㅁㄴㅇㅁㄴㅇㄴㅁㅁㄴㅁㅁㄴㅇㅁㄴㅇㄴㅁㅇㅁㄴㅇㅁㄴㅇㄴㅁㅁㄴㅁㅁㄴㅇㅁㄴㅇㄴㅁㅇㅁㄴㅇㅁㄴㅇㄴㅁㅁㄴㅁㅁㄴㅇㅁㄴㅇㄴㅁㅇㅁㄴㅇㅁㄴㅇㄴㅁㅁㄴㅁㅁㄴㅇㅁㄴㅇㄴㅁㅇㅁㄴㅇㅁㄴㅇㄴㅁㅁㄴㅁㅁㄴㅇㅁㄴㅇㄴㅁㅇㅁㄴㅇㅁㄴㅇㄴㅁㅁㄴㅁㅁㄴㅇㅁㄴㅇㄴㅁㅇㅁㄴㅇㅁㄴㅇㄴㅁㅁㄴ
### 다른 방식의 논리삭제

### 논리삭제시 주의 해야할 점
관련된 글을 찾던 중에... 어느 한 블로그에서 논리삭제를 할때 조회 속도를 위해서 `삭제 여부` 칼럼을 id와 묶어야 한다는 것을 보게 되었다.  

일단 테스트 해보기 위해서 다음 스크립트로 게시판에 100,000개의 더미데이터를 집어넣었다.
```python
import mysql.connector
from faker import Faker
import random

# MySQL 연결 정보
host = "host"  # MySQL 호스트
user = "username"  # MySQL 사용자 이름
password = "password"  # MySQL 비밀번호
database = "database"  # 사용할 데이터베이스 이름

# 더미 데이터 생성을 위한 Faker 객체 생성
fake = Faker()

# MySQL 서버에 연결
try:
    connection = mysql.connector.connect(
        host=host,
        user=user,
        password=password,
        database=database
    )

    if connection.is_connected():
        cursor = connection.cursor()

        # 더미 데이터 생성 및 테이블에 삽입
        num_records = 100000  # 생성할 더미 데이터의 총 개수
        batch_size = 100    # 벌크 삽입할 배치 크기

        for i in range(0, num_records, batch_size):
            batch_records = []
            for _ in range(batch_size):
                title = fake.sentence(nb_words=3)
                writer_id = random.randint(1, 150)
                writer_name = fake.first_name()
                created_at = fake.date_time_between(start_date="-1y", end_date="now")
                read_cnt = random.randint(1, 1000)
                like_cnt = random.randint(1, 1000)
                is_deleted = random.choice([False, False, False, True])

                batch_records.append((title, writer_id, writer_name, created_at, read_cnt, like_cnt, is_deleted))

            # 벌크 삽입 실행
            query = f"INSERT INTO board (title, writer_id, writer_name, created_at, read_cnt, like_cnt, is_deleted) " \
                    f"VALUES (%s, %s, %s, %s, %s, %s, %s)"
            cursor.executemany(query, batch_records)
            connection.commit()

        # 연결 종료
        cursor.close()
        connection.close()

        print(f"{num_records}개의 더미 데이터가 테이블에 삽입되었습니다.")

except Exception as e:
    print(f"오류: {str(e)}")

```
{: file='더미데이터 추가 스크립트.python'}



<!--
근데 데이터 조회속도가 인덱스 추가했을때(index랑 삭제여부 칼럼)랑 또이또이함...
두개를 하나의 필드로 묶어야되나?? 흠
-->

